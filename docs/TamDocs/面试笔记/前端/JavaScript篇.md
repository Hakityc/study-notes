# JavaScript篇

> 本篇主要记录了一些关于Kimi模拟JS面试的内容[对话链接](https://kimi.moonshot.cn/chat/ct76emu9e5jm5q2954j0)。
>
> prompt :
参考这个<https://www.yuque.com/cuggz/interview/vgbphi>  ，请你作为面试官 ，向我提问，请你根据一定的逻辑向我逐个提问，请你从第一个问题开始逐个提问，在我答完之后，请你：以md的格式记录一份针对该问题简短好记的概括，而且要包含： （回答的内容 、答错的内容、漏答的内容、总结） 四个无序列表。

## 第1题：`typeof null` 的结果是什么，为什么？

- **答错的内容：**
  - 无
- **漏答的内容：**
  - 为什么 `typeof null` 返回 `"object"`。
- **正确内容总结：**
  - `typeof null` 的结果是 `"object"`。这是因为在早期的JavaScript规范中，`null` 被错误地归类为 `"object"` 类型，尽管这个设计在后来的规范中被纠正，但为了保持向后兼容性，`typeof null` 返回 `"object"` 的行为被保留下来。

## 第2题：`Array.isArray()` 方法的作用是什么？

- **答错的内容：**
  - 无
- **漏答的内容：**
  - `Array.isArray()` 是ES5中引入的方法，并且它不会受到对象原型链的影响。
- **正确内容总结：**
  - `Array.isArray()` 用于判断一个对象是否为数组。

## 第3题：JavaScript中有哪些数组的遍历方法？

- **答错的内容：**
  - `for...in` 用于遍历对象的属性，而不是数组。
- **漏答的内容：**
  - 除了 `for...of` 和 `forEach`，还有其他数组遍历方法，如 `for` 循环、`map`、`filter`、`reduce`、`some` 和 `every`。
- **正确内容总结：**
  - `for...of` 用于遍历数组中的每个元素；`forEach` 是数组的方法，用于对数组中的每个元素执行一次提供的函数。

## 第4题：JavaScript中的`this`指向是如何确定的？

- **答错的内容：**
  - `this` 并不总是指向父级，它的指向是由函数的调用方式决定的。
- **漏答的内容：**
  - `this` 的指向有多种情况，包括作为对象方法调用、构造函数调用、作为独立函数调用、使用 `call`、`apply`、`bind` 方法调用等。
- **正确内容总结：**
  - 箭头函数中的 `this` 指向是固定的，它继承自外围最近一层非箭头函数的 `this` 绑定。

## 第5题：解释JavaScript中的原型继承机制

- **答错的内容：**
  - `__proto__` 是对象内部属性的一个非标准属性，且原型继承不仅仅是在声明对象时建立的。
- **漏答的内容：**
  - 原型继承的核心是每个对象都有一个内部链接指向另一个对象，称为其原型；原型链的查找过程。
- **正确内容总结：**
  - 每个对象都有一个内部属性 `[[Prototype]]`（在大多数现代浏览器中可以通过 `__proto__` 访问），这个属性指向该对象的原型。

## 第6题：解释JavaScript中的闭包是什么，以及它的用途

- **答错的内容：**
  - 闭包不仅仅是“外部访问对象内部的一种实现”。
- **漏答的内容：**
  - 闭包的定义；闭包的常见用途，如数据封装和私有化、延长变量的生命周期、函数工厂、模块化。
- **正确内容总结：**
  - 闭包是那些能够访问自由变量（即定义在包含函数内，但在包含函数之外的变量）的函数。

## 第7题：解释JavaScript中的`Promise`是什么，以及它的三种状态

- **答错的内容：**
  - `Promise` 不是宏任务，而是一个用来异步执行代码的对象。
- **漏答的内容：**
  - `Promise` 的三种状态的详细解释：`pending`、`fulfilled` 和 `rejected`。
- **正确内容总结：**
  - `Promise` 是一个代表异步操作的对象，它有三种状态：pending（进行中）、fulfilled（已成功）和 rejected（已失败）。

## 第8题：解释JavaScript中的`var`、`let`和`const`关键字的区别

- **答错的内容：**
  - `var` 声明的变量不仅限于全局变量。
- **漏答的内容：**
  - `var` 的变量提升和函数提升；`let` 和 `const` 的暂时性死区。
- **正确内容总结：**
  - `var` 声明的变量具有函数作用域或全局作用域，存在变量提升；`let` 和 `const` 声明的变量具有块级作用域，不存在变量提升，存在暂时性死区。

## 问题9：解释JavaScript中的事件冒泡和事件捕获

### 回答的内容

- 事件冒泡是因为HTML是树形结构，子元素的行为会逐级响应到父级元素。
- 事件捕获是父级元素对事件的响应。
- 常用于树形结构元素，例如树形下拉框。

### 答错的内容

- 事件捕获描述不准确，事件捕获是从父级元素向子元素传播，而不是父级对子元素的响应。

### 漏答的内容

- 未提及事件冒泡和事件捕获的具体过程和三个阶段：捕获阶段、目标阶段和冒泡阶段。
- 未详细说明事件冒泡和事件捕获在实际开发中的其他应用场景。

### 总结

- **事件冒泡**：当在HTML文档中的元素上触发事件时，如果该事件不被捕获，则会一直冒泡到根节点。这个过程称为事件冒泡。
  - **正确**：描述了事件冒泡的基本过程。
  - **错误**：未提及事件冒泡的具体阶段和详细过程。
- **事件捕获**：事件捕获是事件处理机制的第一阶段，事件从文档根节点开始，一直向下传播到目标节点。
  - **正确**：提到了事件捕获的概念。
  - **错误**：描述不准确，事件捕获不是父级对子元素的响应，而是事件从根节点向目标节点传播的过程。
- **应用场景**：
  - **事件冒泡**：常用于实现事件委托，例如处理一组按钮的点击事件。
  - **事件捕获**：较少直接使用，但在需要在事件到达目标元素之前进行拦截或处理时有用，例如，日志记录或权限检查。
  - **树形结构**：事件冒泡和捕获都适用于树形结构的UI组件，如树形菜单，可以用于管理节点的展开和折叠。
